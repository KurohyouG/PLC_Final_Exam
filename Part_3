/* expr
 Parses strings in the language generated by the rule:
 <expr> -> <assi> {(= | += | -= | *= | /= | %= | &= | ^= | |= | <<= | >>= | >>>=) <assi>}
 */
void expr(void) {
	 printf("Enter <expr>\n");
	/* Parse the first assi */
	 assi();
	/* As long as the next token is an assignment operation, get
	 the next token and parse the next assi */
	 while (nextToken == A_OP || nextToken == ADDA_OP || nextToken == SUBA_OP || nextToken == MULA_OP || nextToken == DIVA_OP || nextToken == MODA_OP || nextToken == ANDA_OP || nextToken == XORA_OP || nextToken == ORA_OP || nextToken == SHLA_OP || nextToken == SHRA_OP || nextToken == SHR2A_OP) {
		 lex();
		 assi();
	 }
	 printf("Exit <expr>\n");
}
/* assi
 Parses strings in the language generated by the rule:
 <assi> -> <logor> {|| <logor>}
 */
void assi(void) {
	 printf("Enter <assi>\n");
	/* Parse the first logor */
	 logor();
	/* As long as the next token is ||, get the
	 next token and parse the next logor */
	 while (nextToken == ORL_OP ) {
		 lex();
		 logor();
	 }
	 printf("Exit <assi>\n");
}
/* logor
 Parses strings in the language generated by the rule:
 <logor> -> <logand> {&& <logand>}
 */
void logor(void) {
	 printf("Enter <logor>\n");
	/* Parse the first logand */
	 logand();
	/* As long as the next token is &&, get the
	 next token and parse the next logand */
	 while (nextToken == ANDL_OP ) {
		 lex();
		 logand();
	 }
	 printf("Exit <logor>\n");
}
/* logand
 Parses strings in the language generated by the rule:
 <logand> -> <equ> {(== | != <equ>}
 */
void logand(void) {
	 printf("Enter <logand>\n");
	/* Parse the first equ */
	 equ();
	/* As long as the next token is == or !=, get the
	 next token and parse the next equ */
	 while (nextToken == EQU_OP || nextToken == NEQU_OP) {
		 lex();
		 equ();
	 }
	 printf("Exit <logand>\n");
}
/* equ
 Parses strings in the language generated by the rule:
 <equ> -> <rel> {(> | >= | < | <=) <rel>}
 */
void equ(void) {
	 printf("Enter <equ>\n");
	/* Parse the first rel */
	 rel();
	/* As long as the next token is >, <, >=, or <=, get
	 the next token and parse the next rel */
	 while (nextToken == GT_OP || nextToken == LT_OP || nextToken == GTE_OP || nextToken == LTE_OP) {
		 lex();
		 rel();
	 }
	 printf("Exit <equ>\n");
}
/* rel
 Parses strings in the language generated by the rule:
 <rel> -> <term> {(+ | -) <term>}
 */
void rel(void) {
	 printf("Enter <rel>\n");
	/* Parse the first term */
	 term();
	/* As long as the next token is + or -, get
	 the next token and parse the next term */
	 while (nextToken == ADD_OP || nextToken == SUB_OP) {
		 lex();
		 term();
	 }
	 printf("Exit <rel>\n");
}
/* term
 Parses strings in the language generated by the rule:
 <term> -> <factor> {(* | / | %) <factor>}
 */
void term(void) {
	 printf("Enter <term>\n");
	/* Parse the first factor */
	 factor();
	/* As long as the next token is * or /, get the
	 next token and parse the next factor */
	 while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
		 lex();
		 factor();
	 }
	 printf("Exit <term>\n");
}
/* factor
 Parses strings in the language generated by the rule:
 <factor> -> {(- | -- | + | ++ | !)} <preu> 
 */
void factor(void) {
	 printf("Enter <factor>\n");
	/* Parse the first preu */
	 preu();
	/* As long as the previous token was -, --, +, ++, or !, get the
	 next token and parse the next preu */
	 while (prevToken == SUBU_OP || prevToken == SUBUD_OP || prevToken == ADDU_OP || prevToken == ADDUD_OP || prevToken == NOTUL_OP) {
		 lex();
		 preu();
	 }
	 printf("Exit <term>\n");
}
/* preu
 Parses strings in the language generated by the rule:
 <preu> -> <postu> {(++ | --)}
 */
void preu(void) {
	 printf("Enter <preu>\n");
	/* Parse the first term */
	 postu();
	/* As long as the next token is ++ or --, get
	 the next token and parse the next postu */
	 while (nextToken == ADDPD_OP || nextToken == SUBPD_OP) {
		 lex();
		 postu();
	 }
	 printf("Exit <preu>\n");
}
/* postu
 Parses strings in the language generated by the rule:
 <postu> -> id | int_constant | ( <expr> )
 */
void postu(void) {
	 printf("Enter <postu>\n");
	/* Determine which RHS */
	 if (nextToken == IDENT || nextToken == INT_LIT)
		/* Get the next token */
		 lex();
		/* If the RHS is ( <expr> ), call lex to pass over the
		 left parenthesis, call expr, and check for the right
		 parenthesis */
	 else { if (nextToken == LEFT_PAREN) {
		 lex();
		 expr();
		 if (nextToken == RIGHT_PAREN)
		 	lex();
		 else
		 	error();
		 }
		/* It was not an id, an integer literal, or a left
		 parenthesis */
		 else
		 error();
	 }
	 printf("Exit <postu>\n");
}
